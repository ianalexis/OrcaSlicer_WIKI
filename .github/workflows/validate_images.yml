name: Validate OrcaSlicer Images

on:
  pull_request:
    paths:
      - '**/*.md'
      - '**/*.markdown'
      - '**/*.mdown'
      - '**/*.mkd'
      - '**/*.mkdn'
      - '**/*.mdx'
      - '**/*.html'
      - '**/*.htm'

jobs:
  image-link-validation:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: validate_orca_images
        name: Validate OrcaSlicer image references
        uses: actions/github-script@v7
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');

            const OWNER = 'OrcaSlicer';
            const ownerLower = OWNER.toLowerCase();
            const currentRepo = context.repo.repo;
            const workspace = process.cwd();
            const allowedExt = new Set(['.md', '.markdown', '.mdown', '.mkd', '.mkdn', '.mdx', '.html', '.htm']);
            const reportPath = path.join(process.env.RUNNER_TEMP || workspace, 'orca_invalid_images.json');

            fs.writeFileSync(reportPath, '[]');
            core.exportVariable('INVALID_REPORT_PATH', reportPath);
            core.exportVariable('INVALID_COUNT', '0');

            const baseSha = process.env.BASE_SHA;
            const headSha = process.env.HEAD_SHA;
            if (!baseSha || !headSha) {
              core.setFailed('Missing base/head commit SHAs.');
              return;
            }

            let diffOutput = '';
            try {
              diffOutput = execSync(`git diff --name-only ${baseSha}..${headSha}`, { encoding: 'utf8' }).trim();
            } catch (error) {
              core.setFailed(`git diff failed: ${error.message}`);
              return;
            }

            if (!diffOutput) {
              core.info('No files changed; skipping image validation.');
              return;
            }

            const candidateFiles = diffOutput.split(/\r?\n/)
              .map((file) => file.trim())
              .filter(Boolean)
              .filter((file) => allowedExt.has(path.extname(file).toLowerCase()))
              .filter((file) => fs.existsSync(path.join(workspace, file)));

            if (!candidateFiles.length) {
              core.info('No Markdown or HTML files changed; skipping image validation.');
              return;
            }

            const markdownImagePattern = /!\[[^\]]*\]\(\s*(?<url>[^)\s]+)(?:\s+"[^"]*")?\s*\)/g;
            const htmlImagePattern = /<img[^>]+src=(?:"([^"]+)"|'([^']+)')/gi;

            const references = [];

            for (const relativePath of candidateFiles) {
              const absolutePath = path.join(workspace, relativePath);
              const text = fs.readFileSync(absolutePath, 'utf8');

              const addReference = (url, index) => {
                const line = lineFromIndex(text, index);
                const repoPath = parseOrcaLink(url);
                if (repoPath) {
                  references.push({ filePath: relativePath, line, url, repoPath });
                }
              };

              markdownImagePattern.lastIndex = 0;
              let match;
              while ((match = markdownImagePattern.exec(text)) !== null) {
                const url = match.groups ? match.groups.url : match[1];
                if (url) {
                  addReference(url.trim(), match.index);
                }
              }

              htmlImagePattern.lastIndex = 0;
              while ((match = htmlImagePattern.exec(text)) !== null) {
                const url = match[1] || match[2];
                if (url) {
                  addReference(url.trim(), match.index);
                }
              }
            }

            if (!references.length) {
              core.info('No OrcaSlicer image links found in updated files.');
              return;
            }

            const cache = new Map();

            const failures = [];
            for (const reference of references) {
              if (reference.repoPath.needsRawQuery && !reference.repoPath.hasRawQuery) {
                failures.push({ ...reference, reason: 'missingRawQuery' });
                continue;
              }
              // eslint-disable-next-line no-await-in-loop
              const exists = await repoPathExists(reference.repoPath, currentRepo, workspace, cache);
              if (!exists) {
                failures.push({ ...reference, reason: 'missingFile' });
              }
            }

            if (failures.length) {
              const report = failures.map((failure) => {
                const rp = failure.repoPath;
                const message = failure.reason === 'missingRawQuery'
                  ? `${failure.filePath}:${failure.line}: missing required ?raw=true query parameter`
                  : `${failure.filePath}:${failure.line}: ${OWNER}/${rp.repo}:${rp.ref}/${rp.path} not found`;
                return {
                  filePath: failure.filePath.replace(/\\/g, '/'),
                  line: failure.line,
                  url: failure.url,
                  reason: failure.reason,
                  message,
                };
              });

              fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
              core.exportVariable('INVALID_COUNT', String(report.length));

              core.summary
                .addHeading('Invalid OrcaSlicer image references', 3)
                .addTable([
                  [{ data: 'Archivo', header: true }, { data: 'Línea', header: true }, { data: 'Detalle', header: true }],
                  ...report.map((entry) => [entry.filePath, String(entry.line), entry.message]),
                ])
                .write();

              core.info(`Found ${report.length} invalid OrcaSlicer image link(s).`);
              return;
            }

            core.info(`Validated ${references.length} OrcaSlicer image link(s) across ${candidateFiles.length} file(s).`);

            function lineFromIndex(text, index) {
              let line = 1;
              for (let i = 0; i < index; i += 1) {
                if (text.charCodeAt(i) === 10) {
                  line += 1;
                }
              }
              return line;
            }

            function parseOrcaLink(rawUrl) {
              let parsed;
              try {
                parsed = new URL(rawUrl);
              } catch (_) {
                return null;
              }

              const scheme = parsed.protocol.replace(':', '').toLowerCase();
              if (!['http', 'https'].includes(scheme)) {
                return null;
              }

              const hostname = parsed.hostname.toLowerCase();
              if (!['github.com', 'raw.githubusercontent.com'].includes(hostname)) {
                return null;
              }

              const parts = parsed.pathname.split('/').filter(Boolean);
              if (!parts.length || parts[0].toLowerCase() !== ownerLower) {
                return null;
              }

              if (hostname === 'github.com') {
                if (parts.length < 5) {
                  return null;
                }
                const repo = parts[1];
                const blobOrRaw = parts[2];
                const ref = decodeURIComponent(parts[3]);
                if (!['blob', 'raw'].includes(blobOrRaw)) {
                  return null;
                }
                const relPath = decodeURIComponent(parts.slice(4).join('/'));
                const rawParam = parsed.searchParams.get('raw');
                const hasRawQuery = typeof rawParam === 'string' && rawParam.toLowerCase() === 'true';
                return { repo, ref, path: relPath, needsRawQuery: true, hasRawQuery };
              }

              if (hostname === 'raw.githubusercontent.com') {
                if (parts.length < 4) {
                  return null;
                }
                const repo = parts[1];
                const ref = decodeURIComponent(parts[2]);
                const relPath = decodeURIComponent(parts.slice(3).join('/'));
                return { repo, ref, path: relPath, needsRawQuery: false, hasRawQuery: true };
              }

              return null;
            }

            async function repoPathExists(repoPath, currentRepoName, root, cacheMap) {
              const key = `${repoPath.repo}|${repoPath.ref}|${repoPath.path}`;
              if (cacheMap.has(key)) {
                return cacheMap.get(key);
              }

              let exists;
              if (repoPath.repo === currentRepoName) {
                const normalized = path.normalize(repoPath.path);
                const candidate = path.join(root, normalized);
                exists = candidate.startsWith(root) && fs.existsSync(candidate);
              } else {
                exists = await remoteExists(repoPath);
              }

              cacheMap.set(key, exists);
              return exists;
            }

            async function remoteExists(repoPath) {
              const encodedPath = repoPath.path
                .split('/')
                .filter(Boolean)
                .map((segment) => encodeURIComponent(segment))
                .join('/');
              const ref = encodeURIComponent(repoPath.ref);
              const url = `https://api.github.com/repos/${OWNER}/${repoPath.repo}/contents/${encodedPath}?ref=${ref}`;
              const headers = {
                Accept: 'application/vnd.github+json',
                'User-Agent': 'orca-image-validator',
                'X-GitHub-Api-Version': '2022-11-28',
              };
              if (process.env.GITHUB_TOKEN) {
                headers.Authorization = `Bearer ${process.env.GITHUB_TOKEN}`;
              }

              const response = await fetch(url, { headers });
              if (response.status === 200) {
                return true;
              }
              if (response.status === 404) {
                return false;
              }
              const body = await response.text();
              throw new Error(`GitHub API ${response.status} for ${url}: ${body}`);
            }

      - name: Report invalid image references
        uses: actions/github-script@v7
        env:
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        with:
          script: |
            const invalidCount = Number(process.env.INVALID_COUNT || '0');
            const reportPath = process.env.INVALID_REPORT_PATH;
            if (!invalidCount || !reportPath) {
              core.info('No invalid references to report.');
              return;
            }

            const fs = require('fs');
            let issues = [];
            try {
              if (fs.existsSync(reportPath)) {
                issues = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
              }
            } catch (error) {
              core.warning(`Unable to read invalid reference report: ${error.message}`);
            }

            if (!Array.isArray(issues) || !issues.length) {
              core.info('Invalid reference report empty; skipping annotations.');
              return;
            }

            const pullNumber = context.payload.pull_request.number;
            const headSha = process.env.HEAD_SHA || context.payload.pull_request.head.sha;

            const reviewComments = issues
              .filter((item) => Number.isInteger(item.line) && item.line > 0)
              .slice(0, 50)
              .map((item) => ({
                path: item.filePath,
                line: item.line,
                side: 'RIGHT',
                body: `⚠️ Imagen inválida: ${item.message}\n\nURL: ${item.url}`,
              }));

            if (reviewComments.length) {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pullNumber,
                commit_id: headSha,
                event: 'COMMENT',
                comments: reviewComments,
                body: 'Se detectaron referencias a imágenes de OrcaSlicer que no son válidas.',
              });
              core.info(`Posted ${reviewComments.length} review comment(s) on the PR.`);
            } else {
              core.warning('No valid line information available to annotate files.');
            }

            core.setFailed(`Detected ${issues.length} invalid OrcaSlicer image link(s).`);
