name: Validate OrcaSlicer Images

on:
  pull_request:
    paths:
      - '**/*.md'
      - '**/*.markdown'
      - '**/*.mdown'
      - '**/*.mkd'
      - '**/*.mkdn'
      - '**/*.mdx'
      - '**/*.html'
      - '**/*.htm'

jobs:
  image-link-validation:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate OrcaSlicer image references
        uses: actions/github-script@v7
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');

            const OWNER = 'OrcaSlicer';
            const ownerLower = OWNER.toLowerCase();
            const currentRepo = context.repo.repo;
            const workspace = process.cwd();
            const allowedExt = new Set(['.md', '.markdown', '.mdown', '.mkd', '.mkdn', '.mdx', '.html', '.htm']);

            const baseSha = process.env.BASE_SHA;
            const headSha = process.env.HEAD_SHA;
            if (!baseSha || !headSha) {
              core.setFailed('Missing base/head commit SHAs.');
              return;
            }

            let diffOutput = '';
            try {
              diffOutput = execSync(`git diff --name-only ${baseSha}..${headSha}`, { encoding: 'utf8' }).trim();
            } catch (error) {
              core.setFailed(`git diff failed: ${error.message}`);
              return;
            }

            if (!diffOutput) {
              core.info('No files changed; skipping image validation.');
              return;
            }

            const candidateFiles = diffOutput.split(/\r?\n/)
              .map((file) => file.trim())
              .filter(Boolean)
              .filter((file) => allowedExt.has(path.extname(file).toLowerCase()))
              .filter((file) => fs.existsSync(path.join(workspace, file)));

            if (!candidateFiles.length) {
              core.info('No Markdown or HTML files changed; skipping image validation.');
              return;
            }

            const markdownImagePattern = /!\[[^\]]*\]\(\s*(?<url>[^)\s]+)(?:\s+"[^"]*")?\s*\)/g;
            const htmlImagePattern = /<img[^>]+src=(?:"([^"]+)"|'([^']+)')/gi;

            const references = [];

            for (const relativePath of candidateFiles) {
              const absolutePath = path.join(workspace, relativePath);
              const text = fs.readFileSync(absolutePath, 'utf8');

              const addReference = (url, index) => {
                const line = lineFromIndex(text, index);
                const repoPath = parseOrcaLink(url);
                if (repoPath) {
                  references.push({ filePath: relativePath, line, url, repoPath });
                }
              };

              markdownImagePattern.lastIndex = 0;
              let match;
              while ((match = markdownImagePattern.exec(text)) !== null) {
                const url = match.groups ? match.groups.url : match[1];
                if (url) {
                  addReference(url.trim(), match.index);
                }
              }

              htmlImagePattern.lastIndex = 0;
              while ((match = htmlImagePattern.exec(text)) !== null) {
                const url = match[1] || match[2];
                if (url) {
                  addReference(url.trim(), match.index);
                }
              }
            }

            if (!references.length) {
              core.info('No OrcaSlicer image links found in updated files.');
              return;
            }

            const cache = new Map();

            const failures = [];
            for (const reference of references) {
              if (reference.repoPath.needsRawQuery && !reference.repoPath.hasRawQuery) {
                failures.push({ ...reference, reason: 'missingRawQuery' });
                continue;
              }
              // eslint-disable-next-line no-await-in-loop
              const exists = await repoPathExists(reference.repoPath, currentRepo, workspace, cache);
              if (!exists) {
                failures.push({ ...reference, reason: 'missingFile' });
              }
            }

            if (failures.length) {
              const lines = failures.map((failure) => {
                const rp = failure.repoPath;
                if (failure.reason === 'missingRawQuery') {
                  return `${failure.filePath} line ${failure.line}: add ?raw=true to ${failure.url}`;
                }
                return `${failure.filePath} line ${failure.line}: missing ${OWNER}/${rp.repo}:${rp.ref}/${rp.path}`;
              });
              core.setFailed(`Invalid OrcaSlicer image references:\n${lines.join('\n')}`);
              return;
            }

            core.info(`Validated ${references.length} OrcaSlicer image link(s). All exist.`);

            function lineFromIndex(text, index) {
              let line = 1;
              for (let i = 0; i < index; i += 1) {
                if (text.charCodeAt(i) === 10) {
                  line += 1;
                }
              }
              return line;
            }

            function parseOrcaLink(rawUrl) {
              let parsed;
              try {
                parsed = new URL(rawUrl);
              } catch (_) {
                return null;
              }

              const scheme = parsed.protocol.replace(':', '').toLowerCase();
              if (!['http', 'https'].includes(scheme)) {
                return null;
              }

              const hostname = parsed.hostname.toLowerCase();
              if (!['github.com', 'raw.githubusercontent.com'].includes(hostname)) {
                return null;
              }

              const parts = parsed.pathname.split('/').filter(Boolean);
              if (!parts.length || parts[0].toLowerCase() !== ownerLower) {
                return null;
              }

              if (hostname === 'github.com') {
                if (parts.length < 5) {
                  return null;
                }
                const repo = parts[1];
                const blobOrRaw = parts[2];
                const ref = decodeURIComponent(parts[3]);
                if (!['blob', 'raw'].includes(blobOrRaw)) {
                  return null;
                }
                const relPath = decodeURIComponent(parts.slice(4).join('/'));
                const rawParam = parsed.searchParams.get('raw');
                const hasRawQuery = typeof rawParam === 'string' && rawParam.toLowerCase() === 'true';
                return { repo, ref, path: relPath, needsRawQuery: true, hasRawQuery };
              }

              if (hostname === 'raw.githubusercontent.com') {
                if (parts.length < 4) {
                  return null;
                }
                const repo = parts[1];
                const ref = decodeURIComponent(parts[2]);
                const relPath = decodeURIComponent(parts.slice(3).join('/'));
                return { repo, ref, path: relPath, needsRawQuery: false, hasRawQuery: true };
              }

              return null;
            }

            async function repoPathExists(repoPath, currentRepoName, root, cacheMap) {
              const key = `${repoPath.repo}|${repoPath.ref}|${repoPath.path}`;
              if (cacheMap.has(key)) {
                return cacheMap.get(key);
              }

              let exists;
              if (repoPath.repo === currentRepoName) {
                const normalized = path.normalize(repoPath.path);
                const candidate = path.join(root, normalized);
                exists = candidate.startsWith(root) && fs.existsSync(candidate);
              } else {
                exists = await remoteExists(repoPath);
              }

              cacheMap.set(key, exists);
              return exists;
            }

            async function remoteExists(repoPath) {
              const encodedPath = repoPath.path
                .split('/')
                .filter(Boolean)
                .map((segment) => encodeURIComponent(segment))
                .join('/');
              const ref = encodeURIComponent(repoPath.ref);
              const url = `https://api.github.com/repos/${OWNER}/${repoPath.repo}/contents/${encodedPath}?ref=${ref}`;
              const headers = {
                Accept: 'application/vnd.github+json',
                'User-Agent': 'orca-image-validator',
                'X-GitHub-Api-Version': '2022-11-28',
              };
              if (process.env.GITHUB_TOKEN) {
                headers.Authorization = `Bearer ${process.env.GITHUB_TOKEN}`;
              }

              const response = await fetch(url, { headers });
              if (response.status === 200) {
                return true;
              }
              if (response.status === 404) {
                return false;
              }
              const body = await response.text();
              throw new Error(`GitHub API ${response.status} for ${url}: ${body}`);
            }
